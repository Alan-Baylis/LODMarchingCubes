using System.Collections.Generic;
using UnityEngine;


// index3d(x, y, z) x*dim^2 + y*dim + z
// if(onMin)
// getEdge3d(x, y, z, w) (x*dim^2 + y*dim + z) * 3 + w


namespace MarchingCubes {
    public static class FastMC2 {
        public static MCMesh PolygonizeArea(Vector3 min, float size, int resolution, sbyte[][][] data) {
            MCMesh m = new MCMesh();

            int res1 = resolution + 1;

            List<Vector3> vertices = new List<Vector3>();
            List<int> triangles = new List<int>();
            int[] edges = new int[res1 * res1 * res1 * 3];

            CreateVertices(edges, vertices, res1, data);

            Debug.Log("vertex count: " + vertices.Count);

            Triangulate(edges, triangles, resolution, data);

            Debug.Log("index count: " + triangles.Count);

            m.Vertices = vertices;
            m.Triangles = triangles.ToArray();

            return m;
        }
        public static void CreateVertices(int[] edges, List<Vector3> vertices, int res1, sbyte[][][] data) {
            int edgeNum = 0;
            int vertNum = 0;
            for(int x = 0; x < res1; x++) {
                for(int y = 0; y < res1; y++) {
                    for(int z = 0; z < res1; z++) {
                        for(int w = 0; w < 3; w++) {
                            int offsetX = EdgeOffsets[w,0];
                            int offsetY = EdgeOffsets[w,1];
                            int offsetZ = EdgeOffsets[w,2];

                            //int edgeNum = GetEdge3D(x, y, z, res1, w);
                            if(x + offsetX < 0 || y + offsetY < 0 || z + offsetZ < 0) {
                                edges[edgeNum] = -1;
                                edgeNum++;
                                continue;
                            }
                        
                            sbyte density1 = data[x][y][z];
                            sbyte density2 = data[x + offsetX][y + offsetY][z + offsetZ];

                            // this might be wrong - trying to detect sign change
                            if((density1 < 0 && density2 < 0) || (density1 > 0 && density2 > 0)) {
                                edges[edgeNum] = -1;
                                edgeNum++;
                                continue;
                            }

                            edges[edgeNum] = vertNum;
                            vertNum++;
                            vertices.Add(Lerp(density1, density2, x, y, z, x + offsetX, y + offsetY, z + offsetZ));
                        }
                    }
                }
            }
        }
        public static void Triangulate(int[] edges, List<int> triangles, int resolution, sbyte[][][] data) {
            sbyte[] densities = new sbyte[8];
            int i;
            int mcEdge;

            for(int x = 0; x < resolution; x++) {
				for(int y = 0; y < resolution; y++) {
					for(int z = 0; z < resolution; z++) {
                        byte caseCode = 0;

                        densities[0] = data[x  ][y  ][z  ];
                        densities[1] = data[x + 1][y][z];
                        densities[2] = data[x + 1][y + 1][z];
                        densities[3] = data[x][y + 1][z];
                        densities[4] = data[x][y][z + 1];
                        densities[5] = data[x + 1][y][z + 1];
                        densities[6] = data[x + 1][y + 1][z + 1];
                        densities[7] = data[x][y + 1][z + 1];
                        if (densities[0] < 0) caseCode |= 1;
                        if (densities[1] < 0) caseCode |= 2;
                        if (densities[2] < 0) caseCode |= 4;
                        if (densities[3] < 0) caseCode |= 8;
                        if (densities[4] < 0) caseCode |= 16;
                        if (densities[5] < 0) caseCode |= 32;
                        if (densities[6] < 0) caseCode |= 64;
                        if (densities[7] < 0) caseCode |= 128;

                        if(caseCode == 0 || caseCode == 255) return;

                        for (i = 0; Tables.triTable[caseCode][i] !=-1; i++) {
                            mcEdge = Tables.triTable[caseCode][i];

                            int edgeNum = MCEdgeToEdgeNum(x, y, z, resolution + 1, mcEdge);
                            
                            triangles.Add(edges[edgeNum]);
                        }
                    }
                }
            }
        }

        public static float mu;
        public static Vector3 Lerp(float density1, float density2, float x1, float y1, float z1, float x2, float y2, float z2) {
            /*if(density1 < 0.00001f && density1 > -0.00001f) {
                return new Vector3(x1, y1, z1);
            }
            if(density2 < 0.00001f && density2 > -0.00001f) {
                return new Vector3(x2, y2, z2);
            }
            if(Mathf.Abs(density1 - density2) < 0.00001f) {
                return new Vector3(x2, y2, z2);
            }*/

            mu = (density1) / (density1 - density2); 

            return new Vector3(x1 + mu * (x2 - x1), y1 + mu * (y2 - y1), z1 + mu * (z2 - z1));
        }

        public static int GetEdge3D(int x, int y, int z, int res, int edgeNum) {
            return (3 * ((x * res * res) + (y * res) + z)) + edgeNum;
        }

        // probably incorrect - need to do testing
        public static int MCEdgeToEdgeNum(int x, int y, int z, int res, int mcEdge) {
            if(mcEdge == 4) {
                return GetEdge3D(x, y, z, res, 0);
            }
            if(mcEdge == 9) {
                return GetEdge3D(x, y, z, res, 1);
            }
            if(mcEdge == 5) {
                return GetEdge3D(x, y, z, res, 2);
            }

            if(mcEdge == 8) {
                return GetEdge3D(x - 1, y, z, res, 1);
            }
            if(mcEdge == 7) {
                return GetEdge3D(x - 1, y, z, res, 2);
            }

            if(mcEdge == 6) {
                return GetEdge3D(x, y, z + 1, res, 0);
            }
            if(mcEdge == 10) {
                return GetEdge3D(x, y, z + 1, res, 1);
            }

            if(mcEdge == 0) {
                return GetEdge3D(x, y - 1, z, res, 0);
            }
            if(mcEdge == 1) {
                return GetEdge3D(x, y - 1, z, res, 2);
            }

            if(mcEdge == 3) {
                return GetEdge3D(x - 1, y - 1, z, res, 2); 
            }
            if(mcEdge == 2) {
                return GetEdge3D(x, y - 1, z + 1, res, 0); 
            }
            if(mcEdge == 11) {
                return GetEdge3D(x -1, y, z + 1, res, 1);
            }
            Debug.Assert(false);
            return -1;
        }

        public static readonly int[,] EdgeOffsets = {
            {-1, 0, 0}, {0, -1, 0}, {0, 0, -1}
        };


    }


    struct MCEdge {
        //public float vertPosition;
        public int index; // -1 = no index
    }
}
