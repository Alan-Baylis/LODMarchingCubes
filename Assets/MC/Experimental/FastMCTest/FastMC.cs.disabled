using System.Collections.Generic;
using UnityEngine;

using Transvoxel.Math;
using Transvoxel.Lengyel;
using Transvoxel.VolumeData;
using Transvoxel.SurfaceExtractor;
//using Util;

namespace MarchingCubes {
    public static class FastMC {

		public static readonly Vector3[] OFFSETS = {
            new Vector3(0f,0f,0f), new Vector3(1f,0f,0f), new Vector3(1f,1f,0f), new Vector3(0f,1f,0f), 
            new Vector3(0f,0f,1f), new Vector3(1f,0f,1f), new Vector3(1f,1f,1f), new Vector3(0f,1f,1f) 
        };	

        public static ExtractionResult PolygonizeArea(Vector3 min, float size, int resolution, WorldChunk<sbyte> data) {
        	ExtractionResult r = new ExtractionResult();

			Debug.Log("resolution: " + resolution);

			List<Vertex> vertices = new List<Vertex>();
			List<int> indices = new List<int>();
			RegularCellCache cache = new RegularCellCache(resolution);

			IList<Vertex> ivertices = vertices;
			IList<int> iindices = indices;

			for(int x = 0; x < resolution; x++) {
				for(int y = 0; y < resolution; y++) {
					for(int z = 0; z < resolution; z++) {
						PolygonizeRegularCell(new Vector3i(1, 1, 1), new Vector3f(0, 0, 0), new Vector3i(x, y, z), data, 0, 1f, ref ivertices, ref iindices, ref cache);

					}
				}
			}

			Vector3[] vert2s = new Vector3[vertices.Count];
			Vector3[] normals = new Vector3[vertices.Count];

			for(int i = 0; i < vertices.Count; i++) {
				UnityEngine.Vector3 a = new UnityEngine.Vector3(vertices[i].Primary.X, vertices[i].Primary.Y, vertices[i].Primary.Z);
				vert2s[i] = a;
				UnityEngine.Vector3 b = new UnityEngine.Vector3(vertices[i].Normal.X, vertices[i].Normal.Y, vertices[i].Normal.Z);
				normals[i] = b;
			}

			r.Vertices = vert2s;
			r.Normals = normals;
			r.Triangles = indices.ToArray();

			return r;

			/*
				ExtractionResult r = new ExtractionResult();

				List<Vector3> vertices = new List<Vector3>();

				GridCell cell = new GridCell();
				cell.points = new Point[8];
				for(int i = 0; i < 8; i++) {
					cell.points[i] = new Point();
					cell.points[i].position = new Vector3();
				}

				for(int x = 0; x < resolution; x++) {
					for(int y = 0; y < resolution; y++) {
						for(int z = 0; z < resolution; z++) {
							for(int i = 0; i < 8; i++) {
								cell.points[i].position = new Vector3(size* (x + OFFSETS[i].x), 
																	size * (y + OFFSETS[i].y), 
																	size * (z + OFFSETS[i].z));

								cell.points[i].density = sample(cell.points[i].position);
							}
							SE.Polyganiser.Polyganise(cell, vertices, 0f);
						}
					}
				}

				r.Triangles = new int[vertices.Count];
				for(int i = 0; i < vertices.Count; i ++) { r.Triangles[i] = i; }
				r.Vertices = vertices.ToArray();

				return r;*/
        }

		public static readonly float isovalue = 0f;

        public static int PolygonizeRegularCell(Vector3i min, Vector3f offset, Vector3i xyz,
                                                WorldChunk<sbyte> samples, byte lodIndex, float cellSize,
                                                ref IList<Vertex> verts, ref IList<int> indices, ref Transvoxel.SurfaceExtractor.RegularCellCache cache)
        {

            int lodScale = 1 << lodIndex;
            int last = 15 * lodScale;
            byte directionMask = (byte)((xyz.X > 0 ? 1 : 0) | ((xyz.Y > 0 ? 1 : 0) << 1) | ((xyz.Z > 0 ? 1 : 0) << 2));
            byte near = 0;

            // Compute which of the six faces of the block that the vertex 
            // is near. (near is defined as being in boundary cell.)
            for (int i = 0; i < 3; i++)
            {
                //Vertex close to negative face.
                if (min[i] == 0) { near |= (byte)(1 << (i * 2 + 0)); }
                //Vertex close to positive face.
                if (min[i] == last) { near |= (byte)(1 << (i * 2 + 1)); }
            }

            Vector3i[] cornerPositions = Tables.CornerIndex;
            for (int i = 0; i < cornerPositions.Length; i++)
            {
                cornerPositions[i] = min + cornerPositions[i] * lodScale;
            }

            //  new Vector3i[]
            //      {
            //          min + new Vector3i(0, 0, 0)*lodScale,
            //          min + new Vector3i(1, 0, 0)*lodScale,
            //          min + new Vector3i(0, 1, 0)*lodScale,
            //          min + new Vector3i(1, 1, 0)*lodScale,
            //
            //          min + new Vector3i(0, 0, 1)*lodScale,
            //          min + new Vector3i(1, 0, 1)*lodScale,
            //          min + new Vector3i(0, 1, 1)*lodScale,
            //          min + new Vector3i(1, 1, 1)*lodScale
            //      };

            Vector3i dif = cornerPositions[7] - cornerPositions[1];

            // Retrieve sample values for all the corners.
            sbyte[] cornerSamples =
                new sbyte[]
                    {
                        samples[cornerPositions[0]],
                        samples[cornerPositions[1]],
                        samples[cornerPositions[2]],
                        samples[cornerPositions[3]],
                        samples[cornerPositions[4]],
                        samples[cornerPositions[5]],
                        samples[cornerPositions[6]],
                        samples[cornerPositions[7]],
                    };

            Vector3f[] cornerNormals = new Vector3f[8];

            // Determine the index into the edge table which
            // tells us which vertices are inside of the surface
            uint caseCode = (uint)(((cornerSamples[0] >> 7) & 0x01)
                                 | ((cornerSamples[1] >> 6) & 0x02)
                                 | ((cornerSamples[2] >> 5) & 0x04)
                                 | ((cornerSamples[3] >> 4) & 0x08)
                                 | ((cornerSamples[4] >> 3) & 0x10)
                                 | ((cornerSamples[5] >> 2) & 0x20)
                                 | ((cornerSamples[6] >> 1) & 0x40)
                                 | (cornerSamples[7] & 0x80));

            cache[xyz].CaseIndex = (byte)caseCode;
            if ((caseCode ^ ((cornerSamples[7] >> 7) & 0xff)) == 0)
                return 0;

            // Compute the normals at the cell corners using central difference.
            for (int i = 0; i < 8; ++i)
            {
                var p = cornerPositions[i];
                float nx = (samples[p + Vector3i.UnitX] - samples[p - Vector3i.UnitX]) * 0.5f;
                float ny = (samples[p + Vector3i.UnitY] - samples[p - Vector3i.UnitY]) * 0.5f;
                float nz = (samples[p + Vector3i.UnitZ] - samples[p - Vector3i.UnitZ]) * 0.5f;
                cornerNormals[i] = new Vector3f(nx, ny, nz);
                cornerNormals[i].Normalize();
            }

            var c = Tables.RegularCellClass[caseCode];
            var data = Tables.RegularCellData[c];

            byte nt = (byte)data.GetTriangleCount();
            byte nv = (byte)data.GetVertexCount();

            int[] localVertexMapping = new int[12];


            var vert = new Vertex();
            vert.Near = near;
            // Generate all the vertex positions by interpolating along
            // each of the edges that intersect the isosurface.
            for (int i = 0; i < nv; i++)
            {
                ushort edgeCode = Tables.RegularVertexData[caseCode][i];
                byte v0 = HiNibble((byte)(edgeCode & 0xFF));
                byte v1 = LoNibble((byte)(edgeCode & 0xFF));

                Vector3i p0 = cornerPositions[v0];
                Vector3i p1 = cornerPositions[v1];
                Vector3f n0 = cornerNormals[v0];
                Vector3f n1 = cornerNormals[v1];

                int d0 = samples[p0];
                int d1 = samples[p1];

                Debug.Assert(v0 < v1);

                int t = (d1 << 8) / (d1 - d0);
                int u = 0x0100 - t;

                float t0 = t * S;
                float t1 = u * S;

                if ((t & 0x00ff) != 0)
                {
                    // Vertex lies in the interior of the edge.
                    byte dir = HiNibble((byte)(edgeCode >> 8));
                    byte idx = LoNibble((byte)(edgeCode >> 8));
                    bool present = (dir & directionMask) == dir;

                    if (present)
                    {
                        var prev = cache[xyz + PrevOffset(dir)];

                        // I don't think this can happen for non-corner vertices.
                        if (prev.CaseIndex == 0 || prev.CaseIndex == 255)
                        {
                            localVertexMapping[i] = -1;
                        }
                        else
                        {
                            localVertexMapping[i] = prev.Verts[idx];
                        }
                    }
                    if (!present || localVertexMapping[i] < 0)
                    {
                        localVertexMapping[i] = verts.Count;
                        Vector3f pi = Interp(p0, p1, p0, p1, samples, lodIndex);
                        vert.Primary = offset + pi;
                        vert.Normal = n0 * t0 + n1 * t1;

                        if (near > 0)
                        {
                            Vector3f delta = ComputeDelta(pi, lodIndex, 16);
                            vert.Secondary = vert.Primary + ProjectNormal(vert.Normal, delta);
                        }
                        else
                        {
                            // The vertex is not in a boundary cell, so the 
                            // secondary position will never be used.
                            vert.Secondary = Unused; //vert.Primary;
                        }
                        verts.Add(vert);

                        if ((dir & 8) != 0)
                        {
                            // Store the generated vertex so that other cells can reuse it.
                            cache[xyz].Verts[idx] = localVertexMapping[i];
                        }
                    }
                }
                else if (t == 0 && v1 == 7)
                {
                    // This cell owns the vertex, so it should be created.
                    localVertexMapping[i] = verts.Count;
                    Vector3f pi = (Vector3f)p1 * t0 + (Vector3f)p1 * t1;

                    vert.Primary = offset + pi;
                    vert.Normal = n0 * t0 + n1 * t1;

                    if (near > 0)
                    {
                        Vector3f delta = ComputeDelta(pi, lodIndex, 16);
                        vert.Secondary = vert.Primary + ProjectNormal(vert.Normal, delta);
                    }
                    else
                    {
                        // The vertex is not in a boundary cell, so the secondary 
                        // position will never be used.
                        vert.Secondary = Unused;
                    }
                    verts.Add(vert);
                    cache[xyz].Verts[0] = localVertexMapping[i];
                }
                else
                {
                    // A 3-bit direction code leading to the proper cell can easily be obtained by 
                    // inverting the 3-bit corner index (bitwise, by exclusive ORing with the number 7).
                    // The corner index depends on the value of t, t = 0 means that we're at the higher
                    // numbered endpoint.
                    byte dir = t == 0 ? (byte)(v1 ^ 7) : (byte)(v0 ^ 7);
                    bool present = (dir & directionMask) == dir;

                    if (present)
                    {
                        var prev = cache[xyz + PrevOffset(dir)];

                        // The previous cell might not have any geometry, and we 
                        // might therefore have to create a new vertex anyway.
                        if (prev.CaseIndex == 0 || prev.CaseIndex == 255)
                        {
                            localVertexMapping[i] = -1;
                        }
                        else
                        {
                            localVertexMapping[i] = prev.Verts[0];
                        }
                    }

                    if (!present || (localVertexMapping[i] < 0))
                    {
                        localVertexMapping[i] = verts.Count;

                        Vector3f pi = (Vector3f)p0 * t0 + (Vector3f)p1 * t1;
                        vert.Primary = offset + pi;
                        vert.Normal = n0 * t0 + n1 * t1;

                        if (near > 0)
                        {
                            Vector3f delta = ComputeDelta(pi, lodIndex, 16);
                            vert.Secondary = vert.Primary + ProjectNormal(vert.Normal, delta);
                        }
                        else
                        {
                            vert.Secondary = Unused;
                        }
                        verts.Add(vert);
                    }
                }
            }

            for (int t = 0; t < nt; t++)
            {
                for (int i = 0; i < 3; i++)
                {
                    indices.Add(localVertexMapping[data.Indizes()[t * 3 + i]]);
                }
            }

            return nt;
        }

        public const int BlockWidth = 16;
        public const int Primary = 0;
        public const int Secondary = 1;
        private const float S = 1.0f / 256.0f;
        private static readonly Vector3f Unused = new Vector3f(1000, 1000, 1000);

        private static byte HiNibble(byte b)
        {
            return (byte)(((b) >> 4) & 0x0F);
        }

        private static byte LoNibble(byte b)
        {
            return (byte)(b & 0x0F);
        }

        private static int Sign(sbyte b)
        {
            return (b >> 7) & 1;
        }

        private static Vector3f Interp(Vector3i v0, Vector3i v1, Vector3i p0, Vector3i p1, WorldChunk<sbyte> samples, byte lodIndex = 0)
        {
            return Interp((Vector3f)v0, (Vector3f)v1, p0, p1, samples, lodIndex);
        }

        private static Vector3f Interp(Vector3f v0, Vector3f v1, Vector3i p0, Vector3i p1, WorldChunk<sbyte> samples, byte lodIndex = 0)
        {
            sbyte s0 = samples[p0];
            sbyte s1 = samples[p1];

            int t = (s1 << 8) / (s1 - s0);
            int u = 0x0100 - t;

            if ((t & 0x00ff) == 0)
            {
                // The generated vertex lies at one of the corners so there 
                // is no need to subdivide the interval.
                if (t == 0)
                {
                    return v1;
                }
                return v0;
            }
            else
            {
                for (int i = 0; i < lodIndex; ++i)
                {
                    Vector3f vm = (v0 + v1) / 2;
                    Vector3i pm = (p0 + p1) / 2;

                    sbyte sm = samples[pm];

                    // Determine which of the sub-intervals that contain 
                    // the intersection with the isosurface.
                    if (Sign(s0) != Sign(sm))
                    {
                        v1 = vm;
                        p1 = pm;
                        s1 = sm;
                    }
                    else
                    {
                        v0 = vm;
                        p0 = pm;
                        s0 = sm;
                    }
                }
                t = (s1 << 8) / (s1 - s0);
                u = 0x0100 - t;

                return v0 * t * S + v1 * u * S;
            }
        }

        private static Vector3f ComputeDelta(Vector3f v, int k, int s)
        {
            float p2k = (float)System.Math.Pow(2.0, k); // 1 << k would do the job much more efficient
            float wk = (float)System.Math.Pow(2.0, k - 2.0); // 1 << (k-2)
            Vector3f delta = Vector3f.Zero;

            if (k < 1)
            {
                return delta;
            }

            // x
            float p = v.X;
            float p2mk = (float)System.Math.Pow(2.0, -k);
            if (p < p2k)
            {
                // The vertex is inside the minimum cell.
                delta.X = (1.0f - p2mk * p) * wk;
            }
            else if (p > (p2k * (s - 1)))
            {
                // The vertex is inside the maximum cell.
                delta.X = ((p2k * s) - 1.0f - p) * wk;
            }

            // y
            p = v.Y;
            if (p < p2k)
            {
                // The vertex is inside the minimum cell.
                delta.Y = (1.0f - p2mk * p) * wk;
            }
            else if (p > (p2k * (s - 1)))
            {
                // The vertex is inside the maximum cell.
                delta.Y = ((p2k * s) - 1.0f - p) * wk;
            }

            // z
            p = v.Z;
            if (p < p2k)
            {
                // The vertex is inside the minimum cell.
                delta.Z = (1.0f - p2mk * p) * wk;
            }
            else if (p > (p2k * (s - 1)))
            {
                // The vertex is inside the maximum cell.
                delta.Z = ((p2k * s) - 1.0f - p) * wk;
            }

            return delta;
        }

        private static Vector3f ProjectNormal(Vector3f n, Vector3f delta)
        {
            //return Vector3f.Cross(n, delta);
            var mat = new Matrix3X3(
                   1.0f - n.X * n.X, -n.X * n.Y, -n.X * n.Z,
                   -n.X * n.Y, 1.0f - n.Y * n.Y, -n.Y * n.Z,
                   -n.X * n.Z, -n.Y * n.Z, 1.0f - n.Z * n.Z);
            return mat * delta;
        }

        private static Vector3i PrevOffset(byte dir)
        {
            return new Vector3i(-(dir & 1),
                                    -((dir >> 1) & 1),
                                    -((dir >> 2) & 1));
        }


        /*public static void PolygonizeCell(Vector3 min, float size, MCBasics.Sample sample) {
			Vector3[] vertlist = new Vector3[12];

			int i,ntriang;
			int cubeindex;

			cubeindex = 0;
			if (cell.points[0].density < isovalue) cubeindex |= 1;
			if (cell.points[1].density < isovalue) cubeindex |= 2;
			if (cell.points[2].density < isovalue) cubeindex |= 4;
			if (cell.points[3].density < isovalue) cubeindex |= 8;
			if (cell.points[4].density < isovalue) cubeindex |= 16;
			if (cell.points[5].density < isovalue) cubeindex |= 32;
			if (cell.points[6].density < isovalue) cubeindex |= 64;
			if (cell.points[7].density < isovalue) cubeindex |= 128;

			if (edgeTable[cubeindex] == 0) {
				return;

			}

			if ((edgeTable[cubeindex] & 1) == 1)
				vertlist[0] = UtilFuncs.Lerp(isovalue,cell.points[0],cell.points[1]);
			if ((edgeTable[cubeindex] & 2) == 2)
				vertlist[1] = UtilFuncs.Lerp(isovalue,cell.points[1],cell.points[2]);
			if ((edgeTable[cubeindex] & 4) == 4)
				vertlist[2] = UtilFuncs.Lerp(isovalue,cell.points[2],cell.points[3]);
			if ((edgeTable[cubeindex] & 8) == 8)
				vertlist[3] = UtilFuncs.Lerp(isovalue,cell.points[3],cell.points[0]);
			if ((edgeTable[cubeindex] & 16) == 16)
				vertlist[4] = UtilFuncs.Lerp(isovalue,cell.points[4],cell.points[5]);
			if ((edgeTable[cubeindex] & 32) == 32)
				vertlist[5] = UtilFuncs.Lerp(isovalue,cell.points[5],cell.points[6]);
			if ((edgeTable[cubeindex] & 64) == 64)
				vertlist[6] = UtilFuncs.Lerp(isovalue,cell.points[6],cell.points[7]);
			if ((edgeTable[cubeindex] & 128) == 128)
				vertlist[7] = UtilFuncs.Lerp(isovalue,cell.points[7],cell.points[4]);
			if ((edgeTable[cubeindex] & 256) == 256)
				vertlist[8] = UtilFuncs.Lerp(isovalue,cell.points[0],cell.points[4]);
			if ((edgeTable[cubeindex] & 512) == 512)
				vertlist[9] = UtilFuncs.Lerp(isovalue,cell.points[1],cell.points[5]);
			if ((edgeTable[cubeindex] & 1024) == 1024)
				vertlist[10] = UtilFuncs.Lerp(isovalue,cell.points[2],cell.points[6]);
			if ((edgeTable[cubeindex] & 2048) == 2048)
				vertlist[11] = UtilFuncs.Lerp(isovalue,cell.points[3],cell.points[7]);

			ntriang = 0;
			for (i=0;triTable[cubeindex][i]!=-1;i+=3) {
				ntriang++;
			}
			for (i = 0; triTable[cubeindex][i] !=-1; i++) {
				vertices.Add(vertlist[triTable[cubeindex][i]]);
			}
			
		}


		readonly static int[][] triTable = new int[][] {
			new int[] {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
			new int[] {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
			new int[] {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
			new int[] {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
			new int[] {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
			new int[] {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
			new int[] {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
			new int[] {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
			new int[] {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
			new int[] {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
			new int[] {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
			new int[] {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
			new int[] {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
			new int[] {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
			new int[] {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
			new int[] {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
			new int[] {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
			new int[] {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
			new int[] {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
			new int[] {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
			new int[] {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
			new int[] {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
			new int[] {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
			new int[] {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
			new int[] {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
			new int[] {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
			new int[] {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
			new int[] {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
			new int[] {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
			new int[] {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
			new int[] {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
			new int[] {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
			new int[] {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
			new int[] {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
			new int[] {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
			new int[] {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
			new int[] {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
			new int[] {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
			new int[] {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
			new int[] {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
			new int[] {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
			new int[] {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
			new int[] {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
			new int[] {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
			new int[] {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
			new int[] {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
			new int[] {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
			new int[] {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
			new int[] {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
			new int[] {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
			new int[] {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
			new int[] {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
			new int[] {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
			new int[] {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
			new int[] {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
			new int[] {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
			new int[] {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
			new int[] {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
			new int[] {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
			new int[] {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
			new int[] {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
			new int[] {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
			new int[] {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
			new int[] {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
			new int[] {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
			new int[] {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
			new int[] {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
			new int[] {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
			new int[] {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
			new int[] {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
			new int[] {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
			new int[] {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
			new int[] {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
			new int[] {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
			new int[] {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
			new int[] {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
			new int[] {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
			new int[] {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
			new int[] {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
			new int[] {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
			new int[] {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
			new int[] {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
			new int[] {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
			new int[] {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
			new int[] {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
			new int[] {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
			new int[] {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
			new int[] {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
			new int[] {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
			new int[] {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
			new int[] {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
			new int[] {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
			new int[] {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
			new int[] {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
			new int[] {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
			new int[] {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
			new int[] {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
			new int[] {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
			new int[] {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
			new int[] {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
			new int[] {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
			new int[] {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
			new int[] {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
			new int[] {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
			new int[] {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
			new int[] {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
			new int[] {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
			new int[] {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
			new int[] {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
			new int[] {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
			new int[] {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
			new int[] {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
			new int[] {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
			new int[] {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
			new int[] {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
			new int[] {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
			new int[] {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
		};

		readonly static int[] edgeTable = {
			0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
			0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
			0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
			0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
			0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
			0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
			0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
			0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
			0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
			0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
			0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
			0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
			0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
			0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
			0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
			0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
			0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
			0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
			0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
			0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
			0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
			0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
			0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
			0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
			0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
			0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
			0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
			0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
			0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
			0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
			0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
			0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0   
		};*/
    }
}