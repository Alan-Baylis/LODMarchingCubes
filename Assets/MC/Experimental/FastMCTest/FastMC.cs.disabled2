using System.Collections.Generic;
using UnityEngine;

using Transvoxel.Lengyel;

namespace MarchingCubes {
    public static class FastMC {

		public static readonly Vector3Int[] Offsets = {
            new Vector3Int(0,0,0), new Vector3Int(1,0,0), new Vector3Int(1,1,0), new Vector3Int(0,1,0), 
            new Vector3Int(0,0,1), new Vector3Int(1,0,1), new Vector3Int(1,1,1), new Vector3Int(0,1,1) 
        };	

        public static MCMesh PolygonizeArea(Vector3 min, float size, int resolution, sbyte[][][] data) {
			MCMesh m = new MCMesh();
			m.Vertices = new List<Vector3>();
			m.Triangles = new List<int>();
			m.Normals = new List<Vector3>();

			Vector3Int position = new Vector3Int(0, 0, 0);

			for(int x = 0; x < resolution; x++) {
				for(int y = 0; y < resolution; y++) {
					for(int z = 0; z < resolution; z++) {
						position.Set(x, y, z);
						//Debug.Log("xyz: " + position);
						PolygonizeCell(position, m, data);
					}
				}
			}

			return m;
		}

		public static void PolygonizeCell(Vector3Int offsetPos, MCMesh m, sbyte[][][] data) {
			sbyte[] densities = new sbyte[8];
			byte directionMask = (byte)((offsetPos.x > 0 ? 1 : 0) | ((offsetPos.z > 0 ? 1 : 0) << 1) | ((offsetPos.y > 0 ? 1 : 0) << 2));

			Vector3Int dataPos;
			for (int i = 0; i < densities.Length; i++)
			{
				dataPos = offsetPos + Offsets[i];
				densities[i] = data[dataPos.x][dataPos.y][dataPos.z];
			}

			byte caseCode = GetCaseCode(densities);
			if ((caseCode ^ ((densities[7] >> 7) & 0xFF)) == 0) //for this cases there is no triangulation
			{
				//Debug.Log("Early exit..");
				return;
			}

			Debug.Log("No early exit.");

			byte regularCellClass = Tables.RegularCellClass[caseCode];
			ushort[] vertexLocations = Tables.RegularVertexData[caseCode];

			Tables.RegularCell c = Tables.RegularCellData[regularCellClass];
			long vertexCount = c.GetVertexCount();
			long triangleCount = c.GetTriangleCount();
			byte[] indexOffset = c.Indizes(); //index offsets for current cell
			ushort[] mappedIndizes = new ushort[indexOffset.Length]; //array with real indizes for current cell

			for (int i = 0; i < vertexCount; i++)
			{
				byte edge = (byte)(vertexLocations[i] >> 8);
				byte reuseIndex = (byte)(edge & 0xF); //Vertex id which should be created or reused 1,2 or 3
				byte rDir = (byte)(edge >> 4); //the direction to go to reach a previous cell for reusing 

				byte v1 = (byte)((vertexLocations[i]) & 0x0F); //Second Corner Index
				byte v0 = (byte)((vertexLocations[i] >> 4) & 0x0F); //First Corner Index

				sbyte d0 = densities[v0];
				sbyte d1 = densities[v1];

				//Vector3f n0 = cornerNormals[v0];
				//Vector3f n1 = cornerNormals[v1];

				Debug.Assert(v1 > v0);

				int t = (d1 << 8) / (d1 - d0);
				int u = 0x0100 - t;
				float t0 = t / 256f;
				float t1 = u / 256f;

				int index = -1;

				/*if (UseCache && v1 != 7 && (rDir & directionMask) == rDir)
				{
					Debug.Assert(reuseIndex != 0);
					ReuseCell cell = cache.GetReusedIndex(pos, rDir);
					index = cell.Verts[reuseIndex];
				}*/

				if (index == -1)
				{
					//Vector3 normal = cornerNormals[v0] * t0 + cornerNormals[v1] * t1;
					GenerateVertex(ref offsetPos, ref offsetPos, m, t, ref v0, ref v1, ref d0, ref d1);
					index = m.Vertices.Count - 1;
				}

				/*if ((rDir & 8) != 0)
				{
					cache.SetReusableIndex(pos, reuseIndex, mesh.LatestAddedVertIndex());
				}*/

				mappedIndizes[i] = (ushort)index;
			}

			for (int t = 0; t < triangleCount; t++)
			{
				for (int i = 0; i < 3; i++)
				{
					m.Triangles.Add(mappedIndizes[c.Indizes()[t * 3 + i]]);
				}
			}

		}

		private static void GenerateVertex(ref Vector3Int offsetPos, ref Vector3Int pos, MCMesh m, long t, ref byte v0, ref byte v1, ref sbyte d0, ref sbyte d1)
		{
			Vector3Int iP0 = (offsetPos + Tables.CornerIndex[v0]);
			Vector3 P0;// = new Vector3f(iP0.X, iP0.Y, iP0.Z);
			P0.x = iP0.x;
			P0.y = iP0.y;
			P0.z = iP0.z;

			Vector3Int iP1 = (offsetPos + Tables.CornerIndex[v1]);
			Vector3 P1;// = new Vector3f(iP1.X, iP1.Y, iP1.Z);
			P1.x = iP1.x;
			P1.y = iP1.y;
			P1.z = iP1.z;

			//EliminateLodPositionShift(lod, ref d0, ref d1, ref t, ref iP0, ref P0, ref iP1, ref P1);


			Vector3 Q = InterpolateVoxelVector(t, P0, P1);

			m.Vertices.Add(Q);
			//m.Triangles.Add(m.Vertices.Count - 1);

			//mesh.AddVertex(Q, normal);
		}

		private static byte GetCaseCode(sbyte[] density)
		{
			byte code = 0;
			byte konj = 0x01;
			for (int i = 0; i < density.Length; i++)
			{
				code |= (byte)((density[i] >> (density.Length - 1 - i)) & konj);
				konj <<= 1;
			}

			return code;
		}

		public static Vector3 InterpolateVoxelVector(long t, Vector3 P0, Vector3 P1)
		{
			long u = 0x0100 - t; //256 - t
			float s = 1.0f / 256.0f;
			Vector3 Q = P0 * t + P1 * u; //Density Interpolation
			Q *= s; // shift to shader ! 
			return Q;
		}

	}
}